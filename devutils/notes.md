# Internal development notes

This file contain some receipts, useful in loops development.

# Checking assembly syntax with outer assemblers

## Windows on Intel64

To check compileability of certain assembly lines, you need to use masm, which is part of Visual Studio.
So, open special VS's development CLI(you can find it in Start menu), and use ml64 utility on some assembly file.
```
ml64 probe.asm
```
Example file with normal assembly structure:
```
printf proto
includelib msvcrt.lib
includelib legacy_stdio_definitions.lib

.data
    messenge db "hello", 13, 0

.code
main proc
    sub rsp, 40h
    mov rcx, offset messenge
    call printf
	call check_comp
    add rsp, 40h
    ret
main endp

check_comp proc
	
	;put here code to build check!
	
	ret         
check_comp endp

end
```

## Linux on Intel64

gcc can build .s files into objective file with next command:
```
gcc -c probe.s
```
**Warning**: loops uses only Intel syntax, AT&T is not supported!\
\
Build objective to executable:
```
gcc probe.o -o probe
```
Objective can be disassembled. It's useful to compare hexcodes generated by loops with hexcode generated by normal assembler.
Can be used to check correctness of loops printer syntax. Disassemble command:
```
objdump -D probe.o
```
.s intel syntax assembly file can be generated from .cpp with next command:
```
gcc -S -masm=intel -Og -fverbose-asm probe.cpp
```
There is just working example:
```
        .file   "probe.cpp"
        .intel_syntax noprefix
        .text
        .section        .rodata.str1.1,"aMS",@progbits,1
.LC0:
        .string "Hello"
        .text
        .globl  main
        .type   main, @function
main:
.LFB12:
        .cfi_startproc
        sub     rsp, 8
        .cfi_def_cfa_offset 16
        lea     rdi, .LC0[rip]
        call    puts@PLT
        mov     eax, 0

        #input code to check here!

        add     rsp, 8
        .cfi_def_cfa_offset 8
        ret
        .cfi_endproc
.LFE12:
        .size   main, .-main
        .ident  "GCC: (Debian 10.2.1-6) 10.2.1 20210110"
        .section        .note.GNU-stack,"",@progbits
```

## Linux on Aarch64

gcc can build .s files into objective file with next command:
```
gcc -c probe.s
```
Build objective to executable:
```
gcc probe.o -o probe
```
Objective can be disassembled. It's useful to compare hexcodes generated by loops with hexcode generated by normal assembler.
Can be used to check correctness of loops printer syntax. Disassemble command:
```
objdump -D probe.o
```
**Warning**: Binary instruction represantation in hexacademicals is inverted(big endian). To compare this hex with hex made in loops, invert bytes.\
\
.s intel syntax assembly file can be generated from .cpp with next command:
```
gcc -S -march=armv8.2-a+fp16+dotprod -Og -fverbose-asm probe.cpp
```
There is just working example:
```
	.arch armv8.2-a+crc+fp16+dotprod
	.file	"probe.cpp"
	.text
	.section	.rodata.str1.8,"aMS",@progbits,1
	.align	3
.LC0:
	.string	"Hello!"
	.section	.text.startup,"ax",@progbits
	.align	2
	.p2align 4,,11
	.global	main
	.type	main, %function
main:
.LFB12:
	.cfi_startproc
	stp	x29, x30, [sp, -16]!
	.cfi_def_cfa_offset 16
	.cfi_offset 29, -16
	.cfi_offset 30, -8
	adrp	x0, .LC0
	add	x0, x0, :lo12:.LC0
	mov	x29, sp
	bl	puts
	mov	w0, 0

	#input code to check here!


	ldp	x29, x30, [sp], 16
	.cfi_restore 30
	.cfi_restore 29
	.cfi_def_cfa_offset 0
	ret
	.cfi_endproc
.LFE12:
	.size	main, .-main
	.ident	"GCC: (Debian 12.2.0-14) 12.2.0"
	.section	.note.GNU-stack,"",@progbits
```